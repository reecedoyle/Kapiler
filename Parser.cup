package Kapiler

import java_cup.runtime.*;

terminal TDEF, DEF, VOID, IN, IF, ELSE, FOREACH, WHILE, DO, RETURN, READ, PRINT, CHAR, BOOLEAN, INT, FLOAT, STRING, LIST, DICT, MAIN, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, LDICT, RDICT, SEMI, COMMA, DOT, EQ, EXCLAMATION, AND, PLUS, MINUS, MULT, DIV, POW, CONCAT, LT, LTEQ, NOTEQ, COLON, BOOLEAN_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL, ID, STRING_LITERAL, CHARACTER_LITERAL;

non terminal ;

program		::= decllist main decllist	{: System.out.println("-------end of parsing-------"); :}
	;

main		::= VOID MAIN block
	;

decllist	::= decllist decl
			| 
	;

decl		::= funcdef
			| vardef
			| typedef
	;

body	::= vardef body
		| vareassign
		| control_statment
	;

funcdef		::= DEF type ID LPAREN paramlist RPAREN body
	;

vardef		::= type ID varinit SEMI
	;

varinit		::= EQ varassign
			|
	;

varreassign	::= ID varinit
	;

varassign	::= value
			| dictassign
			| listassign
	;

/*---- DICTS & LISTS ----*/ // Provisionally complete

dictassign	::= LDICT dictdef RDICT
	;

dictdef		::= dictval dictvals
			|
	;

dictvals	::= COMMA dictval dictvals
			|
	;

dictval 	::= value COLON value
	;

listassign	::= LBRACK listdef RBRACK
	;

listdef		::= value listvals
			|
	;

listvals	::= COMMA value listvals
			|
	;

/*------------------------------------*/

/*---- TYPES ----*/

typedef		::= TDEF ID COLON typefield typefields SEMI
	;

typefields	::= typefield typefields
			|
	;

typefield	::= ID COLON type
	;

type		::= CHAR //list of different types for function return
			| BOOLEAN
			| INT
			| FLOAT
			| STRING
			| LIST
			| DICT
			| ID // to account for user-defined types
	;

value 		::= primitive_value
			| STRING_LITERAL
			| boolean_value
			| vals_from_aggs
	;

vals_from_aggs	::= LEN LPAREN ID RPAREN // len(d);
				| ID LBRACK value RBRACK // d[k];
				| vals_from_seq
	;

vals_from_seq	::= seq_literal COLON COLON seq_literal
				| ID LBRACK splice RBACK
	;

splice			::= value COLON value
				| value COLON
				| COLON value
	;

dict_literal	::= dictassign
				| ID
	;

seq_literal		::= listassign
				| ID
				| STRING_LITERAL
	;

primitive_value ::= CHARACTER_LITERAL
			| INTEGER_LITERAL
			| FLOAT_LITERAL
	;

paramlist	::= //parsing of parameters to a function
	;

/*------------------------------------*/

/*---- CONTROL STATEMENTS ----*/
block := LBRACE body RBRACE
	;


control_statement ::= if_statement
					| if_statement else_statement
					| while_statement
					| foreach_statement
	;

if_statement ::= IF LPAREN expr RPAREN block
	;



/*------------------------------------*/


/*---- OPERATORS ----*/
boolean_value ::= BOOLEAN_LITERAL
				| expr
    ;


numeric_operator ::= PLUS
				   | MINUS
				   | MULT
				   | DIV
				   | POW
	;

dict_seq_bool_operator ::= value IN ID
	;

bool_operator ::= EQEQ
				| NOTEQ
				| AND
	;

prim_bool_operator ::= LT
						| LTEQ
						| EQEQ
	;



expr ::= BOOLEAN_LITERAL
		| NOT expr
		| primitive_value prim_bool_operator primitive_value
		| boolean_value bool_operator boolean_value
	;



/*------------------------------------*/
