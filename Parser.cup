package hello;
import java_cup.runtime.*;

parser code {:

	public String rule;
	
	public void report_error(String message, Object info){

		StringBuffer m = new StringBuffer("Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0){
				m.append(" in line "+(s.left+1));
			}
		}
		m.append(": rule \""+rule+"\" violated");
		System.err.println(m);
	}
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}
:};

terminal TDEF, DEF, VOID, IN, IF, ELSE, FOREACH, WHILE, DO, RETURN, READ, PRINT, CHAR, BOOLEAN, INT, FLOAT, STRING, LIST, DICT, MAIN, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, LDICT, RDICT, SEMI, COMMA, DOT, EQ, AND, PLUS, MINUS, MULT, DIV, POW, CONCAT, EQEQ, LT, LTEQ, NOTEQ, COLON, BOOLEAN_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL, ID, STRING_LITERAL, CHARACTER_LITERAL, LEN, NOT;

non terminal program, main, decllist, decl, funcdef, var_def_with_type, varinit, var_def, varassign, dictassign, dictdef, dictelems, dictelem, listassign, listdef, listelems, typedef, typefields, typefield, type, primitive_type, aggregate_type, value, seq_val, vals_from_aggs, numeric_vals_from_aggs, val_from_index, vals_from_seq, splice, formal_param_list_opt, formal_param_list, actual_param_list_opt, actual_param_list, block, body, statement_list, statement, function_call, control_statement, if_statement, else_statement, while_statement, foreach_statement, expr, print, read, oper, function_body;

precedence left EQEQ, LTEQ, NOTEQ, LT, AND, IN;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left POW;

program		::= {: rule = "program"; :} decllist main decllist	{: System.out.println("-------end of parsing-------"); :}
	;

main		::= VOID MAIN block
	;

decllist	::= decl decllist
			| 
	;

decl		::= funcdef
			| var_def_with_type
			| typedef
	;

funcdef		::= DEF type ID LPAREN formal_param_list_opt RPAREN LBRACE function_body RBRACE
	;

var_def_with_type	::= type var_def // eg. int x = 6 ;
	;

var_def		::= ID varinit SEMI // eg. x = 5;
	;

varinit		::= EQ varassign // set the variable to a value or null
			|
	;

varassign	::= expr
	;

/*---- DICTS & LISTS ----*/ // Provisionally complete

dictassign	::= LDICT dictdef RDICT
	;

dictdef		::= dictelem dictelems
			|
	;

dictelems	::= COMMA dictelem dictelems
			|
	;

dictelem 	::= expr COLON expr
	;

listassign	::= LBRACK listdef RBRACK
	;

listdef		::= expr listelems
			|
	;

listelems	::= COMMA expr listelems
			|
	;

/*------------------------------------*/

//

/*---- TYPES ----*/

typedef		::= TDEF ID COLON typefield typefields SEMI
	;

typefields	::= typefield typefields
			|
	;

typefield	::= ID COLON type
	;

type		::= primitive_type //list of different types for function return
			| aggregate_type
	;

primitive_type	::=	CHAR
				| BOOLEAN
				| INT
				| FLOAT
	;

aggregate_type	::= STRING
				| LIST
				| DICT
				| ID // to account for user-defined types
	;



/*---- VALUES ----*/
value 		::= INTEGER_LITERAL
			| FLOAT_LITERAL
			| MINUS value
			| CHARACTER_LITERAL
			| BOOLEAN_LITERAL
			| STRING_LITERAL
			| dictassign
			| listassign
			| vals_from_aggs // idk what to do with this
			| function_call
			| ID
			| ID DOT ID
	;

/*************************
prim_not_bool_value
			| boolean_val
			| aggregate_val
			| function_call // return value from a function
	;

prim_not_bool_value	::= numeric_val
					| char_val
	;

char_val	::= CHARACTER_LITERAL
			| val_from_index
			| ID
	;

numeric_val	::= INTEGER_LITERAL // literals
			| FLOAT_LITERAL
			| MINUS numeric_val // negative numbers
			| numeric_val numeric_oper numeric_val // operations on numbers
			| numeric_vals_from_aggs // len(a), a[i], etc.
			| ID
	;

boolean_val ::= BOOLEAN_LITERAL
			| expr
			| ID
	;

aggregate_val	::= dict_val
				| seq_val
	;

dict_val	::= dictassign
			| ID
	;

seq_val		::= listassign
			| STRING_LITERAL
			| ID
	;
*************************/

vals_from_aggs	::= numeric_vals_from_aggs
				| vals_from_seq
	;

numeric_vals_from_aggs	::= LEN LPAREN ID RPAREN // len(d);
						| val_from_index
	;

val_from_index	::= ID LBRACK value RBRACK // a[i]; d[k];
	;

vals_from_seq	::= seq_val CONCAT seq_val // list :: list;
				| ID LBRACK splice RBRACK // list[i:j]; list[:j]; list[i:];
	;

splice			::= value COLON value
				| value COLON
				| COLON value
	;

/*------------------------------------*/


/*---- PARAMETERS ----*/

formal_param_list_opt	::= type ID formal_param_list
						|
	;

formal_param_list	::= COMMA type ID formal_param_list
					|
	;

actual_param_list_opt	::= value actual_param_list
						|
	;

actual_param_list	::= COMMA value actual_param_list
					|
	;


/*------------------------------------*/

/*---- CONTROL STATEMENTS ----*/
block	::= LBRACE body RBRACE
	;

body	::= statement_list
	;

function_body	::= body RETURN value SEMI
	;

statement_list	::= statement statement_list
				 |
	;

// list possible statements & things. basically general code.
statement 	::= var_def_with_type
			| var_def
			| control_statement
			| function_call
			| read
			| print
			
	;

function_call	::= ID LPAREN actual_param_list_opt RPAREN SEMI
	;

control_statement ::= if_statement
					| if_statement else_statement
					| while_statement
					| foreach_statement
	;

if_statement 	::= IF LPAREN expr RPAREN block
	;

else_statement 	::= ELSE block
	;

while_statement	::= WHILE LPAREN expr RPAREN DO block
	;

foreach_statement	::= FOREACH LPAREN ID COLON ID RPAREN block
	;



/*------------------------------------*/



/*---- OPERATORS ----*/

oper 	::= PLUS
		| MINUS
		| MULT
		| DIV
		| POW
		| IN
		| EQEQ
		| NOTEQ
		| AND
		| LT
		| LTEQ
	;

/*************************
numeric_oper ::= PLUS
			| MINUS
			| MULT
			| DIV
			| POW
	;

dict_seq_bool_oper	::= value IN ID
	;

bool_oper ::= EQEQ
			| NOTEQ
			| AND
	;

prim_not_bool_comparison	::= LT
							| LTEQ
							| EQEQ
							| NOTEQ
	;

*************************/

expr 	::= value
		| expr oper expr
		| NOT expr
	;

/*************************
expr	::= BOOLEAN_LITERAL
		| NOT expr
		| prim_not_bool_value prim_not_bool_comparison prim_not_bool_value
		| boolean_val bool_oper boolean_val
	;
*************************/

/*------------------------------------*/

/*---- I/O ----*/

print ::= PRINT actual_param_list_opt SEMI
	;

read  ::= READ ID SEMI
	;


/*------------------------------------*/
