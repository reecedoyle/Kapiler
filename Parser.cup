package Kapiler

import java_cup.runtime.*;

terminal TDEF, DEF, VOID, IN, IF, ELSE, FOREACH, WHILE, DO, RETURN, READ, PRINT, CHAR, BOOLEAN, INT, FLOAT, STRING, LIST, DICT, MAIN, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, LDICT, RDICT, SEMI, COMMA, DOT, EQ, EXCLAMATION, AND, PLUS, MINUS, MULT, DIV, POW, CONCAT, LT, LTEQ, NOTEQ, COLON, BOOLEAN_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL, ID, STRING_LITERAL, CHARACTER_LITERAL;

non terminal ;

program		::= decllist main decllist	{: System.out.println("-------end of parsing-------"); :}
	;

main		::= VOID MAIN block
	;

decllist	::= decllist decl
			| 
	;

decl		::= funcdef
			| vardef
			| typedef
	;

body	::= vardef body
		| vareassign
		| control_statment
	;

funcdef		::= DEF type ID LPAREN formal_param_list_opt RPAREN body
	;

vardef		::= type ID varinit SEMI
	;

varinit		::= EQ varassign
			|
	;

varreassign	::= ID varinit
	;

varassign	::= value
	;

/*---- DICTS & LISTS ----*/ // Provisionally complete

dictassign	::= LDICT dictdef RDICT
	;

dictdef		::= dictelem dictelems
			|
	;

dictelems	::= COMMA dictelem dictelems
			|
	;

dictelem 	::= value COLON value
	;

listassign	::= LBRACK listdef RBRACK
	;

listdef		::= value listelems
			|
	;

listelems	::= COMMA value listelems
			|
	;

/*------------------------------------*/

/*---- TYPES ----*/

typedef		::= TDEF ID COLON typefield typefields SEMI
	;

typefields	::= typefield typefields
			|
	;

typefield	::= ID COLON type
	;

type		::= CHAR //list of different types for function return
			| BOOLEAN
			| INT
			| FLOAT
			| STRING
			| LIST
			| DICT
			| ID // to account for user-defined types
	;

/*---- VALUES ----*/
value 		::= primitive_value
			| STRING_LITERAL
			| boolean_value
			| vals_from_aggs
	;

numeric_val	::= INTEGER_LITERAL // literals
			| FLOAT_LITERAL
			| MINUS numeric_val // negative numbers
			| numeric_val numeric_oper numeric_val // operations on numbers
			| numeric_vals_from_aggs // len(a), a[i], etc.
			| ID
	;

boolean_val ::= BOOLEAN_LITERAL
			| expr
			| ID
	;

seq_val		::= listassign
			| STRING_LITERAL
			| ID
	;

/*------------------------------------*/
vals_from_aggs	::= numeric_vals_from_aggs
				| vals_from_seq
	;

numeric_vals_from_aggs	::= LEN LPAREN ID RPAREN // len(d);
						| ID LBRACK value RBRACK // a[i]; d[k];
	;

vals_from_seq	::= seq_literal CONCAT seq_literal // list :: list;
				| ID LBRACK splice RBRACK // list[i:j]; list[:j]; list[i:];
	;

splice			::= value COLON value
				| value COLON
				| COLON value
	;

dict_literal	::= dictassign
				| ID
	;

primitive_value ::= CHARACTER_LITERAL
			| INTEGER_LITERAL
			| FLOAT_LITERAL
	;

formal_param_list_opt	::= type ID formal_param_list
						|
	;

formal_param_list	::= COMMA type ID formal_param_list
					|
	;

actual_param_list_opt	::= ID actual_param_list
						|
	;

actual_param_list	::= COMMA ID actual_param_list
					|
	;

/*------------------------------------*/

/*---- CONTROL STATEMENTS ----*/
block := LBRACE body RBRACE
	;


control_statement ::= if_statement
					| if_statement else_statement
					| while_statement
					| foreach_statement
	;

if_statement ::= IF LPAREN expr RPAREN block
	;



/*------------------------------------*/


/*---- OPERATORS ----*/

numeric_oper ::= PLUS
			| MINUS
			| MULT
			| DIV
			| POW
	;

//---- Boolean-returning operators ----//

dict_seq_bool_oper	::= value IN ID
	;

bool_oper ::= EQEQ
		| NOTEQ
		| AND
	;

prim_bool_oper	::= LT
				| LTEQ
				| EQEQ
	;



expr ::= BOOLEAN_LITERAL
		| NOT expr
		| primitive_value prim_bool_oper primitive_value
		| boolean_val bool_oper boolean_val
	;



/*------------------------------------*/
