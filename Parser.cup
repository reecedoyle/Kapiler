package Kapiler

import java_cup.runtime.*;

terminal TDEF, DEF, VOID, IN, IF, ELSE, FOREACH, WHILE, DO, RETURN, READ, PRINT, CHAR, BOOLEAN, INT, FLOAT, STRING, LIST, DICT, MAIN, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, LDICT, RDICT, SEMI, COMMA, DOT, EQ, EXCLAMATION, AND, PLUS, MINUS, MULT, DIV, POW, CONCAT, LT, LTEQ, NOTEQ, COLON, BOOLEAN_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL, ID, STRING_LITERAL, CHARACTER_LITERAL;

non terminal ;

program		::= decllist main decllist	{: System.out.println("-------end of parsing-------"); :}
	;

main		::= VOID MAIN block
	;

decllist	::= decl decllist
			| 
	;

decl		::= funcdef
			| var_def_with_type
			| typedef
	;

funcdef		::= DEF type ID LPAREN formal_param_list_opt RPAREN body
	;

var_def_with_type	::= type var_def // eg. int x = 6 ;
	;

varinit		::= EQ varassign // set the variable to a value or null
			|
	;

var_def		::= ID varinit SEMI // eg. x = 5;
	;

varassign	::= value
			| dictassign
			| listassign
	;

/*---- DICTS & LISTS ----*/ // Provisionally complete

dictassign	::= LDICT dictdef RDICT
	;

dictdef		::= dictelem dictelems
			|
	;

dictelems	::= COMMA dictelem dictelems
			|
	;

dictelem 	::= value COLON value
	;

listassign	::= LBRACK listdef RBRACK
	;

listdef		::= value listelems
			|
	;

listelems	::= COMMA value listelems
			|
	;

/*------------------------------------*/

/*---- TYPES ----*/

typedef		::= TDEF ID COLON typefield typefields SEMI
	;

typefields	::= typefield typefields
			|
	;

typefield	::= ID COLON type
	;

type		::= primitive_type //list of different types for function return
			| aggregate_type
	;

primitive_type	::=	CHAR
				| BOOLEAN
				| INT
				| FLOAT
	;

aggregate_type	::= STRING
				| LIST
				| DICT
				| ID // to account for user-defined types
	;

/*---- VALUES ----*/
value 		::= prim_not_bool_value
			| boolean_val
			| aggregate_val
			| function_call // return value from a function
	;

prim_not_bool_value	::= numeric_val
					| char_val
	;

char_val	::= CHAR_LITERAL
			| val_from_index
			| ID

numeric_val	::= INTEGER_LITERAL // literals
			| FLOAT_LITERAL
			| MINUS numeric_val // negative numbers
			| numeric_val numeric_oper numeric_val // operations on numbers
			| numeric_vals_from_aggs // len(a), a[i], etc.
			| ID
	;

boolean_val ::= BOOLEAN_LITERAL
			| expr
			| ID
	;

aggregate_val	::= dict_val
				| seq_val
	;

dict_val	::= dictassign
			| ID
	;

seq_val		::= listassign
			| STRING_LITERAL
			| ID
	;

vals_from_aggs	::= numeric_vals_from_aggs
				| vals_from_seq
	;

numeric_vals_from_aggs	::= LEN LPAREN ID RPAREN // len(d);
						| val_from_index
	;

val_from_index	::= ID LBRACK value RBRACK // a[i]; d[k];
	;

vals_from_seq	::= seq_literal CONCAT seq_literal // list :: list;
				| ID LBRACK splice RBRACK // list[i:j]; list[:j]; list[i:];
	;

splice			::= value COLON value
				| value COLON
				| COLON value
	;

/*------------------------------------*/

/*---- PARAMETERS ----*/

formal_param_list_opt	::= type ID formal_param_list
						|
	;

formal_param_list	::= COMMA type ID formal_param_list
					|
	;

actual_param_list_opt	::= ID actual_param_list
						|
	;

actual_param_list	::= COMMA ID actual_param_list
					|
	;

//EASTER EGG <@:^)

/*------------------------------------*/

/*---- CONTROL STATEMENTS ----*/
block	:= LBRACE body RBRACE
	;

body	:= statement_list
		|
	;

statement_list	::= statement statement_list
	;

// list possible statements & things. basically general code.
statement 	::= var_def_with_type
			| var_def
			| control_statement
			| function_call
	;

function_call	::= ID LPAREN actual_param_list_opt RPAREN SEMI
	;

control_statement ::= if_statement
					| if_statement else_statement
					| while_statement
					| foreach_statement
	;

if_statement 	::= IF LPAREN expr RPAREN block
	;

else_statement 	::= ELSE block
	;

while_statement	::= WHILE LPAREN expr RPAREN DO block
	;

foreach_statement	::= FOREACH LPAREN ID COLON ID RPAREN block
	;



/*------------------------------------*/


/*---- OPERATORS ----*/

numeric_oper ::= PLUS
			| MINUS
			| MULT
			| DIV
			| POW
	;

//---- Boolean-returning operators ----//

dict_seq_bool_oper	::= value IN ID
	;

bool_oper ::= EQEQ
			| NOTEQ
			| AND
	;

prim_not_bool_comparison	::= LT
							| LTEQ
							| EQEQ
							| NOTEQ
	;




/*------------------------------------*/

expr ::= BOOLEAN_LITERAL
		| NOT expr
		| prim_not_bool_value prim_not_bool_comparison prim_not_bool_value
		| boolean_val bool_oper boolean_val
	;



